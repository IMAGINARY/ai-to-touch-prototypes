<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">

        <title>Gradient descent</title>
        <style type="text/css">
            body {
                margin: 0px;
                padding: 0px;
                background-color: rgb(10, 0, 30);
            }

            #CSCanvas {
              /*16:9*/
                width: 100vw;
                height: 56.25vw;
                max-height: 100vh;
                max-width: 177.77vh;
                filter: invert(1);
            }
        </style>
        <script type="text/javascript" src="common/js/Cindy.js"></script>

      <script id="csinit" type="text/x-cindyscript">
      tanh(x) := (
        (exp(x)-exp(-x))/(exp(x)+exp(-x))
      );

      dtanh(x) := (
        1-tanh(x)^2
      );

      transfer(x):=(
        tanh(x)
      );

      dtransfer(x):=(
        dtanh(x)
      );

      nn(w, x) := (
        transfer(w*x+1)
      );

      dwnn(w, x) := (
        dtransfer(w*x+1)*x
      );

      error(w):= (
        (sum(A,a,(nn(w,a)-1)^2)+sum(B,b,(nn(w,b)+1)^2))/length(A);
      );

      derror(w):= (
        (sum(A,a,2*(nn(w,a)-1)*dwnn(w,a))+sum(B,b,(2*nn(w,b)+1)*dwnn(w,b)))/length(A);
      );

      w = (randomnormal(), randomnormal());
      errc(error(w));
      errc(derror(w));

      f(x) := error(x);
      f(x,y) := error([x,y]);
      df(x) := derror(x);
      df(x,y) := derror([x,y]);

S = 4;
xvals = (-10..10)/10*S;
xyvals = directproduct(xvals, xvals);
exponent = 2;
floorh = 0;

reset():=(
  dragging = false;

  sx = 0;
  sy = 0;
  dx = .05; dy = -.02;
  phi = -.1;
  lambda = pi/3;


  resetclock();
  t0 = 0;
  best = (100,100);

  a = random(2*pi);
  if(autopilot,
    c0 = 1.5*(-1,-1),
    c0 = 2*(cos(a),sin(a))
  );

  a0 = -.2*c0+.3*(randomnormal(), randomnormal());
  b0 = c0+.3*(randomnormal(), randomnormal());
  A = apply(1..20, (randomnormal(), randomnormal())+a0);
  B = apply(1..20, (randomnormal(), randomnormal())+b0);


  best = xyvals_1;
  forall(xyvals, x, if(f(x)<f(best), best=x));
//  );


  plotlines =
    apply(xvals, y,
      apply(xvals,x,
        (x,y,f(x,y))
      )
    )
    ++
    apply(xvals, x,
      apply(xvals,y,
        (x,y,f(x,y))
      )
  );

  pts = [];
  mode = "select";
  N = 5;
);
initpt = -(S*.4,S*.1);
autopilot = true;

reset();


project(x,y,z) := project([x,y,z]);

sceneoffset = [0,.3*S,-5*S];
scenefactor = 35;
project(x) := (
  regional(y);
  y=P*x+sceneoffset;
  scenefactor*(y_1,y_2)/y_3;
);

inverseproject(y) := (
  //inverse([P_1,P_2,[0,0,1]])*(y_1,y_2,floorh)
  regional(A,B,mu);
  y = y/scenefactor;
  //mu * [y_1, y_2, 1] = P*[x_1, x_2, floorh]+sceneoffset)
  A = inverse(P) * [y_1, y_2, 1];
  B = -inverse(P) * sceneoffset;
  mu = (floorh-B_3)/A_3;
  mu*A+B
);

floor(y) := (
  (y_1,y_2,floorh)
);



dot(x,y):=(x*y);


gradientdescent() := (
  regional(gamma, x);
  x = if(pts==[], initpt,
    gamma = if(length(pts)>=2,
      |dot(pts_(-1)-pts_(-2), df(pts_(-1))-df(pts_(-2)))|/dot(df(pts_(-1))-df(pts_(-2)),df(pts_(-1))-df(pts_(-2))) //from https://en.wikipedia.org/wiki/Gradient_descent
      ,
      |pts_1|
    );
    pts_(-1) - gamma*df(pts_(-1))
  );
  apply(x, c, if(|c|>S, c/|c|*S, c)) //clamp into domain
);

      </script>
      <script id="csdraw" type="text/x-cindyscript">

      if(autopilot % mode=="final", dx = .003);
      if (dragging,
          dx = -.3 * (sx - mouse().x); dy = -.3 * (sy - mouse().y);,
          dx = .9*dx; dy = .9*dy;
      );

      sx = mouse().x;
      sy = mouse().y;
///      P = [cos(alpha), cos(seconds())]

phi = phi + dx;
lambda = lambda + dy;
lambda = min(max(lambda,0.1),pi/2-.1);

P = (
    (1, 0, 0),
    (0, cos(lambda), -sin(lambda)),
    (0, sin(lambda), cos(lambda))
)*(
    (cos(phi), -sin(phi), 0),
    (sin(phi), cos(phi), 0),
    (0, 0, 1)
);


//grid
drawall(
  apply(xvals, x,
    [project(x,-S,floorh),project(x,S,floorh)]
  )
  ++
  apply(xvals, y,
    [project(-S,y,floorh),project(S,y,floorh)]
  ),
  color->[.2,.2,.2], alpha->.6
);



forall(if(mode!="compute",1..length(pts),1..(length(pts)-1)), k,
  x = pts_k;
  y = (x_1,x_2,f(x));
  df = df(x);
  c = hue(k*sqrt(.3))*.7;
  draw(project(floor(y)),project(y),color->c);

  n = [-df_1,-df_2, 1];
  n = n/|n|;
  vs = cross(n,[0,0,1]);
  vs = vs/|vs|;
  v = cross(n,vs);


  v = .5*v; vs = .5*vs;


  light = |n*[1,2,3]|*[1,1,1]*(-.1);
  //draw(project(y-v),project(y+v),color->c);
  poly1 = apply([(y-v),(y+v), floor(y+v),floor(y-v)], project(#));
  poly2 = apply([(y-v-vs),(y-v+vs),(y+v+vs), (y+v-vs)], project(#));

  draw(project(y), color->c);
  fillpoly(poly1, alpha->.2,color->c);
  fillpoly(poly2, alpha->.5,color->c+light);
  draw(project(floor(y+v)),project(floor(y-v)),color->c);

);

//plot
if(autopilot,
  forall(plotlines, list, connect(apply(list, project(#)), size->2, alpha->.3));
);



if(autopilot & (mode=="select" % mode=="compute"),
  drawtext((-15,8), "The computer tries to approach the minimum through gradient descent.");
);


if(mode=="select" & !dragging,
  if((N-length(pts))==0, mode="final"; resetclock());

  if(autopilot,
    if(seconds()>.3,
      x = gradientdescent();
      pts = pts :> x;
      mode = "compute";
      resetclock();
    );
    ,
    drawtext((-15,8), "Approach the minimal function value! Click to guess!");
  );
  drawtext((-15,7), "$"+(N-length(pts))+"$ guess"+if((N-length(pts))==1,"","es")+" left");

  if(!autopilot,
    x = inverseproject(mouse().xy);
    if(max(x,|#|)<S,
      y = (x_1,x_2, sin(seconds()));
      draw(project(x), project(y));
      drawtext(project(x),"$x$");
      drawtext(project(y),"$f(x)=?$");
    );

  );
);
/*
if(length(pts)>=2,
  yourbest = pts_1;
  forall(pts, x, if(f(x)<f(yourbest),yourbest=x));
  pb = (yourbest,f(yourbest));
  draw(pb+(-5,0),pb+(5,0), color->[0,1,1], alpha->.3); //TODO
);*/

if(mode=="compute",
  speedfactor = max(5,(1+length(pts)));
  if(speedfactor*seconds()>2,
  	mode = "select";
    resetclock();
  );
  x = pts_(-1);
  //y = min(1,speedfactor*seconds())*f(x);

  par = min(1,speedfactor*seconds());
  y = (x_1,x_2,f(x));
  cy = (1-par)*floor(y)+par*y;

  drawtext(project(floor(y)),"$x$", alpha->par);
  drawtext(project(y),"$f(x)="+format(f(x),2)+"$", alpha->par);
  draw(project(floor(y)),project(cy));
  if(speedfactor*seconds()>1,
    df = df(x);
    a = (speedfactor*seconds()-1);

    n = [-df_1,-df_2, 1];
    n = n/|n|;
    vs = cross(n,[0,0,1]);
    vs = vs/|vs|;
    v = cross(n,vs);
    v = .5*v; vs = .5*vs;

    draw(project(y-a*v),project(y+a*v));
    //drawtext(project(y),"$f'(x)$", alpha->a, angle->arctan2([1,df]), align->"mid");

  );
);

if(mode=="final",
  a = min(1,seconds());
  //plot(f(x),alpha->a);
  forall(plotlines, list, connect(apply(list, project(#)), size->2, alpha->.5*a));

  yourbest = pts_1;
  forall(pts, x, if(f(x)<f(yourbest),yourbest=x));

  err = |f(best)-f(yourbest)|;

  subjectverb = if(autopilot, "The computer has reached", "You have reached");
  if(err<.02,
    drawtext((-15,8), subjectverb + " the global minimum.");
    ,
    drawtext((-15,8), subjectverb + " the global minimum up to $" + format(err,3) + "$.");
  );
  if(!autopilot,
    drawtext((-15,7), "Click to see what the computer would have done.");
    ,
    drawtext((-15,7), "Now it is your turn! Click to restart the applet with another function.");
  );

  draw(project(best_1, best_2, f(best)), size->10, alpha->.8*a);
  draw(project(best_1, best_2, f(best)), project(best_1, best_2,floorh), size->10, alpha->.8*a, color->[0,1,0]);
  draw(project(best_1, best_2, f(best)), project(best_1,best_2, f(yourbest)), size->5, alpha->.8*a, color->[0,1,1]);
);



////classification meaning draw


if(pts!=[],
  w = pts_(-1);,

  x = inverseproject(mouse());
  w = (x_1, x_2);
);

translate((16-4,9-4));
scale(.8);
clip(polygon([[-6,-6],[-6,6],[6,6],[6,-6]]));

draw(line([w_1,w_2,1]));
fill(halfplane(
  line([w_1,w_2,1]),
  point([0,0,1])
), color->hue(0.3), alpha->.2);

fill(halfplane(
  line([w_1,w_2,1]),
  point([-1000*w_1,-1000*w_2,1])
), color->hue(0.8), alpha->.2);



forall(A, a,
  draw(a, color->hue(0.3), alpha->if(nn(w,a)>0,.9,.2))
);
forall(B, b,
  draw(b, color->hue(0.8), alpha->if(nn(w,b)<0,.9,.2))
);


drawtext((0,3.5), align->"mid", "error: $"+format(error(w),2)+"$");

      </script>

<script id="csmousedown" type="text/x-cindyscript">
  sx = mouse().x;
  sy = mouse().y;
  x = inverseproject(mouse());
  //if(|x_1|>pi%|x_2|>pi,
    dragging = true;
  //);
</script>

<script id="csmouseup" type="text/x-cindyscript">
  dragging = false;
</script>

<script id="csmouseclick" type="text/x-cindyscript">
if(mode=="select" & !autopilot & (N-length(pts))>0,
   //x = mouse().x;
   x = inverseproject(mouse());
   if(|x_1|<S&|x_2|<S,
     pts = pts :> [x_1, x_2];
     mode = "compute";
     resetclock();
   );
);

if(mode=="final",
  if(!autopilot,
    initpt = pts_1;
    pts = [];
    mode = "select";
    autopilot = true;
    ,
    reset();
    autopilot = false;
  );
);

      </script>

        <script type="text/javascript">
          var cdy = CindyJS({
            scripts: "cs*",
            geometry: [

            ],
            ports: [
              {id: "CSCanvas", transform: [{visibleRect: [-16, -9, 16, 9]}]}
            ],
            autoplay: true
          });
        </script>
    </head>
    <body>
        <div id="CSCanvas"></div>
    </body>
    </html>
